<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üéÑ C√¢y Th√¥ng Noel 3D</title>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: Arial, sans-serif;
      background: linear-gradient(to bottom, #0a1f2e, #1a3a4a);
    }
    
    #canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      cursor: grab;
    }
    
    #canvas:active {
      cursor: grabbing;
    }
    
    .ui {
      position: fixed;
      color: white;
      font-size: 14px;
      z-index: 10;
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 25px;
      backdrop-filter: blur(10px);
    }
    
    .top-left {
      top: 20px;
      left: 20px;
    }
    
    .top-right {
      top: 20px;
      right: 20px;
      display: flex;
      gap: 10px;
    }
    
    .bottom {
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
    }
    
    button {
      background: rgba(255,255,255,0.2);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      cursor: pointer;
      font-size: 12px;
      font-weight: bold;
      transition: all 0.2s;
    }
    
    button:hover {
      background: rgba(255,255,255,0.3);
    }
    
    button:active {
      transform: scale(0.95);
    }
    
    .instructions {
      position: fixed;
      bottom: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 30px;
      border-radius: 20px;
      color: white;
      text-align: center;
      max-width: 400px;
      z-index: 100;
    }
    
    .instructions h2 {
      margin-bottom: 20px;
      font-size: 24px;
    }
    
    .instructions p {
      margin: 10px 0;
      font-size: 14px;
    }
    
    .hide {
      display: none;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
</head>
<body>
  <!-- Canvas -->
  <canvas id="canvas"></canvas>
  
  <!-- UI -->
  <div class="ui top-left" id="status">
    üñ±Ô∏è K√©o ƒë·ªÉ xoay
  </div>
  
  <div class="ui top-right">
    <div id="fps">60 FPS</div>
    <button onclick="toggleAutoRotate()">‚ñ∂Ô∏è T·ª± ƒë·ªông</button>
    <button onclick="location.reload()">üîÑ</button>
  </div>
  
  <div class="ui bottom">
    ‚ú® Created by V≈© Kim V·ªØng
  </div>
  
  <div class="instructions" id="instructions">
    <h2>üéÑ H∆∞·ªõng d·∫´n</h2>
    <p>üñ±Ô∏è <strong>K√©o chu·ªôt</strong> ƒë·ªÉ xoay c√¢y</p>
    <p>üîç <strong>LƒÉn chu·ªôt</strong> ƒë·ªÉ zoom</p>
    <p>üëÜ <strong>Double-click</strong> ƒë·ªÉ xoay 360¬∞</p>
    <button onclick="hideInstructions()" style="margin-top: 20px;">ƒê√£ hi·ªÉu</button>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  
  <script>
    // ============================================
    // GLOBAL VARIABLES
    // ============================================
    let scene, camera, renderer, tree;
    let isDragging = false;
    let previousMouseX = 0;
    let rotation = 0;
    let targetRotation = 0;
    let scale = 1;
    let targetScale = 1;
    let autoRotate = false;
    let frameCount = 0;
    let lastTime = Date.now();
    
    const canvas = document.getElementById('canvas');
    const statusEl = document.getElementById('status');
    const fpsEl = document.getElementById('fps');
    
    // ============================================
    // SCENE SETUP
    // ============================================
    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0a1f2e);
      
      // Camera
      const aspect = window.innerWidth / window.innerHeight;
      camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
      camera.position.set(0, 3, 8);
      camera.lookAt(0, 2, 0);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ 
        canvas: canvas,
        antialias: true 
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      
      // Lights
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 5);
      scene.add(directionalLight);
      
      const topLight = new THREE.DirectionalLight(0xffffff, 0.4);
      topLight.position.set(0, 15, 0);
      scene.add(topLight);
      
      // Create tree
      createTree();
      
      // Create snow
      createSnow();
      
      // Create ground
      const ground = new THREE.Mesh(
        new THREE.CircleGeometry(12, 32),
        new THREE.MeshPhongMaterial({ color: 0x1a3a4a })
      );
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);
      
      console.log('‚úÖ Scene initialized');
    }
    
    // ============================================
    // CREATE CHRISTMAS TREE
    // ============================================
    function createTree() {
      tree = new THREE.Group();
      
      // Trunk
      const trunk = new THREE.Mesh(
        new THREE.CylinderGeometry(0.2, 0.25, 1, 12),
        new THREE.MeshPhongMaterial({ color: 0x5c3317 })
      );
      trunk.position.y = 0.5;
      tree.add(trunk);
      
      // Foliage
      const green = new THREE.MeshPhongMaterial({ color: 0x0d5c2d });
      
      const tier1 = new THREE.Mesh(new THREE.ConeGeometry(1.3, 1.6, 12), green);
      tier1.position.y = 1.6;
      tree.add(tier1);
      
      const tier2 = new THREE.Mesh(new THREE.ConeGeometry(1, 1.3, 12), green);
      tier2.position.y = 2.5;
      tree.add(tier2);
      
      const tier3 = new THREE.Mesh(new THREE.ConeGeometry(0.7, 1.1, 12), green);
      tier3.position.y = 3.3;
      tree.add(tier3);
      
      // Star
      const star = new THREE.Mesh(
        new THREE.IcosahedronGeometry(0.3, 0),
        new THREE.MeshBasicMaterial({ 
          color: 0xffd700,
          emissive: 0xffd700
        })
      );
      star.position.y = 4.2;
      star.name = 'star';
      tree.add(star);
      
      // Ornaments
      const colors = [0xff0000, 0x0000ff, 0xffd700, 0xff1493, 0x00ff00];
      
      for (let i = 0; i < 15; i++) {
        const ornament = new THREE.Mesh(
          new THREE.SphereGeometry(0.1, 8, 8),
          new THREE.MeshStandardMaterial({
            color: colors[i % colors.length],
            metalness: 0.7,
            roughness: 0.3
          })
        );
        
        const angle = (i * 137.5) * Math.PI / 180;
        const radius = 0.4 + Math.random() * 0.4;
        const height = 1.5 + Math.random() * 2;
        
        ornament.position.set(
          Math.cos(angle) * radius,
          height,
          Math.sin(angle) * radius
        );
        
        tree.add(ornament);
      }
      
      // Light
      const light = new THREE.PointLight(0xffaa00, 2, 8);
      light.position.set(0, 2.2, 0);
      tree.add(light);
      
      scene.add(tree);
      
      console.log('üéÑ Tree created');
    }
    
    // ============================================
    // CREATE SNOW
    // ============================================
    function createSnow() {
      const particleCount = 100;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      
      for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 15;
        positions[i * 3 + 1] = Math.random() * 12;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 15;
      }
      
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.1,
        transparent: true,
        opacity: 0.8
      });
      
      const snow = new THREE.Points(geometry, material);
      snow.name = 'snow';
      scene.add(snow);
      
      console.log('‚ùÑÔ∏è Snow created');
    }
    
    // ============================================
    // ANIMATION LOOP
    // ============================================
    function animate() {
      requestAnimationFrame(animate);
      
      // FPS counter
      frameCount++;
      const now = Date.now();
      if (now - lastTime > 1000) {
        fpsEl.textContent = frameCount + ' FPS';
        frameCount = 0;
        lastTime = now;
      }
      
      // Auto rotate
      if (autoRotate) {
        targetRotation += 0.005;
      }
      
      // Smooth rotation
      rotation += (targetRotation - rotation) * 0.1;
      tree.rotation.y = rotation;
      
      // Smooth scale
      scale += (targetScale - scale) * 0.1;
      tree.scale.set(scale, scale, scale);
      
      // Rotate star
      const star = tree.getObjectByName('star');
      if (star) {
        star.rotation.y += 0.02;
      }
      
      // Animate snow
      const snow = scene.getObjectByName('snow');
      if (snow) {
        const positions = snow.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          positions[i + 1] -= 0.02;
          if (positions[i + 1] < 0) {
            positions[i + 1] = 12;
          }
        }
        snow.geometry.attributes.position.needsUpdate = true;
      }
      
      renderer.render(scene, camera);
    }
    
    // ============================================
    // CONTROLS
    // ============================================
    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      previousMouseX = e.clientX;
      autoRotate = false;
      updateStatus();
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.clientX - previousMouseX;
      targetRotation += deltaX * 0.01;
      previousMouseX = e.clientX;
    });
    
    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });
    
    canvas.addEventListener('mouseleave', () => {
      isDragging = false;
    });
    
    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const delta = e.deltaY * -0.001;
      targetScale = Math.max(0.5, Math.min(2.5, targetScale + delta));
    });
    
    canvas.addEventListener('dblclick', () => {
      const start = targetRotation;
      const duration = 2000;
      const startTime = Date.now();
      
      function spin() {
        const elapsed = Date.now() - startTime;
        if (elapsed < duration) {
          const progress = elapsed / duration;
          targetRotation = start + (Math.PI * 2) * progress;
          requestAnimationFrame(spin);
        }
      }
      
      spin();
    });
    
    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      isDragging = true;
      previousMouseX = e.touches[0].clientX;
      autoRotate = false;
      updateStatus();
    });
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isDragging) return;
      
      const deltaX = e.touches[0].clientX - previousMouseX;
      targetRotation += deltaX * 0.01;
      previousMouseX = e.touches[0].clientX;
    });
    
    canvas.addEventListener('touchend', () => {
      isDragging = false;
    });
    
    // ============================================
    // UI FUNCTIONS
    // ============================================
    function toggleAutoRotate() {
      autoRotate = !autoRotate;
      updateStatus();
    }
    
    function updateStatus() {
      statusEl.textContent = autoRotate ? 'üîÑ T·ª± ƒë·ªông xoay' : 'üñ±Ô∏è K√©o ƒë·ªÉ xoay';
    }
    
    function hideInstructions() {
      document.getElementById('instructions').classList.add('hide');
    }
    
    // Auto hide instructions
    setTimeout(hideInstructions, 8000);
    
    // ============================================
    // RESIZE HANDLER
    // ============================================
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    // ============================================
    // START
    // ============================================
    init();
    animate();
    
    console.log('üöÄ App started');
  </script>
</body>
</html>
