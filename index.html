<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  
  <title>üéÑ AR C√¢y Th√¥ng Noel</title>
  
  <meta name="description" content="ƒêi·ªÅu khi·ªÉn c√¢y th√¥ng Noel 3D b·∫±ng c·ª≠ ch·ªâ tay">
  <meta name="theme-color" content="#165B33">
  
  <!-- CDN Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
  <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1620248168/camera_utils.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: 'Georgia', serif;
      touch-action: none;
      background: #000;
    }
    
    html, body, #root {
      position: fixed;
      width: 100%;
      height: 100%;
    }
    
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-20px); }
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .float-animation {
      animation: float 2s ease-in-out infinite;
    }
    
    /* Debug panel */
    .debug-panel {
      position: fixed;
      bottom: 100px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      color: #0f0;
      padding: 10px;
      font-family: monospace;
      font-size: 10px;
      max-width: 300px;
      z-index: 9999;
      border: 1px solid #0f0;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script>
    'use strict';
    
    const { useState, useEffect, useRef, createElement: h } = React;
    
    // ============================================
    // ENHANCED CONFIGURATION WITH DEBUG
    // ============================================
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    const CONFIG = {
      CAMERA_WIDTH: isMobile ? 640 : 1280,
      CAMERA_HEIGHT: isMobile ? 480 : 720,
      AI_FPS: isMobile ? 10 : 15,
      SNOW_PARTICLES: isMobile ? 60 : 150,
      ORNAMENT_COUNT: isMobile ? 10 : 16,
      ENABLE_ANTIALIASING: !isMobile,
      PIXEL_RATIO: isMobile ? 1 : Math.min(window.devicePixelRatio, 2),
      DAMPING: 0.1,
      ROTATION_SPEED: 0.04,
      DEBUG_MODE: true // Enable debug logs
    };
    
    // ============================================
    // DEBUG LOGGER
    // ============================================
    const debugLog = {
      logs: [],
      add(message) {
        const timestamp = new Date().toLocaleTimeString();
        this.logs.push(`[${timestamp}] ${message}`);
        if (this.logs.length > 10) this.logs.shift();
        console.log('üéÑ', message);
      }
    };
    
    // ============================================
    // MAIN APP
    // ============================================
    function App() {
      const [appState, setAppState] = useState('INIT');
      const [gesture, setGesture] = useState('idle');
      const [fps, setFPS] = useState(0);
      const [showInstructions, setShowInstructions] = useState(true);
      const [errorMessage, setErrorMessage] = useState('');
      const [debugLogs, setDebugLogs] = useState([]);
      
      const videoRef = useRef(null);
      const canvasRef = useRef(null);
      const sceneRef = useRef(null);
      const handsRef = useRef(null);
      const animationFrameRef = useRef(null);
      
      const targetRotation = useRef(0);
      const targetScale = useRef(1);
      const isSpinning = useRef(false);
      const spinStartTime = useRef(0);
      
      const lastFrameTime = useRef(performance.now());
      const frameCount = useRef(0);
      const lastHandSeen = useRef(Date.now());
      
      // Update debug logs
      useEffect(() => {
        const interval = setInterval(() => {
          setDebugLogs([...debugLog.logs]);
        }, 500);
        return () => clearInterval(interval);
      }, []);
      
      // ============================================
      // CAMERA WITH ENHANCED ERROR HANDLING
      // ============================================
      const initCamera = async () => {
        debugLog.add('üé• Initializing camera...');
        
        try {
          // Check if getUserMedia is available
          if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('getUserMedia not supported');
          }
          
          const constraints = {
            video: {
              facingMode: 'user',
              width: { ideal: CONFIG.CAMERA_WIDTH },
              height: { ideal: CONFIG.CAMERA_HEIGHT }
            },
            audio: false
          };
          
          debugLog.add('üìû Requesting camera permission...');
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          
          debugLog.add('‚úÖ Camera permission granted');
          
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            videoRef.current.setAttribute('playsinline', 'true');
            
            await new Promise((resolve, reject) => {
              videoRef.current.onloadedmetadata = () => {
                debugLog.add('üìπ Video metadata loaded');
                videoRef.current.play()
                  .then(() => {
                    debugLog.add('‚ñ∂Ô∏è Video playing');
                    resolve();
                  })
                  .catch(reject);
              };
              
              setTimeout(() => reject(new Error('Video load timeout')), 10000);
            });
          }
          
          return true;
        } catch (err) {
          debugLog.add(`‚ùå Camera error: ${err.message}`);
          console.error('Camera initialization error:', err);
          
          let errorMsg = 'Kh√¥ng th·ªÉ truy c·∫≠p camera';
          if (err.name === 'NotAllowedError') {
            errorMsg = 'B·∫°n ƒë√£ t·ª´ ch·ªëi quy·ªÅn camera. Vui l√≤ng cho ph√©p trong c√†i ƒë·∫∑t tr√¨nh duy·ªát.';
          } else if (err.name === 'NotFoundError') {
            errorMsg = 'Kh√¥ng t√¨m th·∫•y camera tr√™n thi·∫øt b·ªã.';
          }
          
          setErrorMessage(errorMsg);
          setAppState('ERROR');
          return false;
        }
      };
      
      // ============================================
      // THREE.JS WITH DEBUG
      // ============================================
      const initThreeJS = () => {
        debugLog.add('üé® Initializing Three.js...');
        
        try {
          const canvas = canvasRef.current;
          if (!canvas) {
            throw new Error('Canvas not found');
          }
          
          const width = window.innerWidth;
          const height = window.innerHeight;
          
          debugLog.add(`üìê Canvas size: ${width}x${height}`);
          
          // Scene
          const scene = new THREE.Scene();
          scene.background = null; // Transparent
          
          // Camera
          const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
          camera.position.set(0, 2, isMobile ? 6 : 5);
          camera.lookAt(0, 1.5, 0);
          
          // Renderer
          const renderer = new THREE.WebGLRenderer({
            canvas: canvas,
            alpha: true,
            antialias: CONFIG.ENABLE_ANTIALIASING
          });
          
          renderer.setSize(width, height);
          renderer.setPixelRatio(CONFIG.PIXEL_RATIO);
          renderer.setClearColor(0x000000, 0);
          
          debugLog.add('üñ•Ô∏è Renderer created');
          
          // Test WebGL
          const gl = renderer.getContext();
          debugLog.add(`WebGL: ${gl.VERSION}`);
          
          // Lights
          const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
          scene.add(ambientLight);
          
          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
          directionalLight.position.set(5, 10, 5);
          scene.add(directionalLight);
          
          debugLog.add('üí° Lights added');
          
          // ============================================
          // CHRISTMAS TREE
          // ============================================
          const treeGroup = new THREE.Group();
          
          // Trunk
          const trunkGeo = new THREE.CylinderGeometry(0.2, 0.25, 1, 8);
          const trunkMat = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
          const trunk = new THREE.Mesh(trunkGeo, trunkMat);
          trunk.position.y = 0.5;
          treeGroup.add(trunk);
          
          // Foliage
          const foliageMat = new THREE.MeshPhongMaterial({ color: 0x0F5E32 });
          
          const tier1 = new THREE.Mesh(new THREE.ConeGeometry(1.2, 1.5, 8), foliageMat);
          tier1.position.y = 1.5;
          treeGroup.add(tier1);
          
          const tier2 = new THREE.Mesh(new THREE.ConeGeometry(0.9, 1.2, 8), foliageMat);
          tier2.position.y = 2.3;
          treeGroup.add(tier2);
          
          const tier3 = new THREE.Mesh(new THREE.ConeGeometry(0.6, 1, 8), foliageMat);
          tier3.position.y = 3;
          treeGroup.add(tier3);
          
          // Star
          const starGeo = new THREE.IcosahedronGeometry(0.25, 0);
          const starMat = new THREE.MeshBasicMaterial({ 
            color: 0xFFD700,
            emissive: 0xFFD700
          });
          const star = new THREE.Mesh(starGeo, starMat);
          star.position.y = 3.9;
          treeGroup.add(star);
          
          debugLog.add('üéÑ Christmas tree created');
          
          // Ornaments
          const ornamentColors = [0xFF0000, 0x0000FF, 0xFFD700, 0xFF1493, 0x00FF00];
          for (let i = 0; i < CONFIG.ORNAMENT_COUNT; i++) {
            const ornament = new THREE.Mesh(
              new THREE.SphereGeometry(0.08, 8, 8),
              new THREE.MeshStandardMaterial({
                color: ornamentColors[i % ornamentColors.length],
                metalness: 0.7,
                roughness: 0.3
              })
            );
            
            const angle = (i * 137.5) * Math.PI / 180;
            const radius = 0.4 + Math.random() * 0.4;
            const height = 1.2 + Math.random() * 2;
            
            ornament.position.set(
              Math.cos(angle) * radius,
              height,
              Math.sin(angle) * radius
            );
            
            treeGroup.add(ornament);
          }
          
          // Point light
          const pointLight = new THREE.PointLight(0xFFAA00, 2, 8);
          pointLight.position.set(0, 2, 0);
          treeGroup.add(pointLight);
          
          scene.add(treeGroup);
          
          debugLog.add('‚ú® Ornaments added');
          
          // ============================================
          // SNOW PARTICLES
          // ============================================
          const snowGeo = new THREE.BufferGeometry();
          const snowPos = new Float32Array(CONFIG.SNOW_PARTICLES * 3);
          const snowVel = [];
          
          for (let i = 0; i < CONFIG.SNOW_PARTICLES; i++) {
            snowPos[i * 3] = (Math.random() - 0.5) * 12;
            snowPos[i * 3 + 1] = Math.random() * 10;
            snowPos[i * 3 + 2] = (Math.random() - 0.5) * 12;
            snowVel.push(0.01 + Math.random() * 0.02);
          }
          
          snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
          
          const snowMat = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 0.08,
            transparent: true,
            opacity: 0.8
          });
          
          const snowSystem = new THREE.Points(snowGeo, snowMat);
          scene.add(snowSystem);
          
          debugLog.add('‚ùÑÔ∏è Snow system created');
          
          // ============================================
          // ANIMATION LOOP
          // ============================================
          function animate() {
            animationFrameRef.current = requestAnimationFrame(animate);
            
            // FPS counter
            frameCount.current++;
            const now = performance.now();
            if (now - lastFrameTime.current > 1000) {
              setFPS(frameCount.current);
              frameCount.current = 0;
              lastFrameTime.current = now;
            }
            
            // Magic spin
            if (isSpinning.current) {
              const elapsed = (now - spinStartTime.current) / 1000;
              if (elapsed < 2) {
                targetRotation.current += 0.15;
              } else {
                isSpinning.current = false;
              }
            }
            
            // Smooth transforms
            treeGroup.rotation.y += (targetRotation.current - treeGroup.rotation.y) * CONFIG.DAMPING;
            const newScale = treeGroup.scale.x + (targetScale.current - treeGroup.scale.x) * CONFIG.DAMPING;
            treeGroup.scale.set(newScale, newScale, newScale);
            
            // Rotate star
            star.rotation.y += 0.02;
            star.rotation.z += 0.01;
            
            // Snow falling
            const positions = snowGeo.attributes.position.array;
            for (let i = 0; i < CONFIG.SNOW_PARTICLES; i++) {
              positions[i * 3 + 1] -= snowVel[i];
              if (positions[i * 3 + 1] < -1) {
                positions[i * 3 + 1] = 10;
              }
            }
            snowGeo.attributes.position.needsUpdate = true;
            
            renderer.render(scene, camera);
          }
          
          animate();
          debugLog.add('üé¨ Animation started');
          
          sceneRef.current = { scene, camera, renderer, treeGroup };
          
          // Resize handler
          const handleResize = () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
            renderer.setSize(w, h);
          };
          
          window.addEventListener('resize', handleResize);
          
          return () => {
            window.removeEventListener('resize', handleResize);
            if (animationFrameRef.current) {
              cancelAnimationFrame(animationFrameRef.current);
            }
          };
          
        } catch (err) {
          debugLog.add(`‚ùå Three.js error: ${err.message}`);
          console.error('Three.js initialization error:', err);
          setErrorMessage('L·ªói kh·ªüi t·∫°o ƒë·ªì h·ªça 3D');
          setAppState('ERROR');
        }
      };
      
      // ============================================
      // MEDIAPIPE
      // ============================================
      const initMediaPipe = async () => {
        debugLog.add('ü§ñ Initializing MediaPipe...');
        
        try {
          const hands = new Hands({
            locateFile: (file) => {
              return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
            }
          });
          
          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: isMobile ? 0 : 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
          
          hands.onResults(onHandResults);
          await hands.initialize();
          
          debugLog.add('‚úÖ MediaPipe ready');
          
          handsRef.current = hands;
          
          // Detection loop
          let isProcessing = false;
          async function detect() {
            if (videoRef.current && handsRef.current && !isProcessing) {
              isProcessing = true;
              try {
                await handsRef.current.send({ image: videoRef.current });
              } catch (err) {
                console.warn('Detection error:', err);
              } finally {
                isProcessing = false;
              }
            }
            setTimeout(detect, 1000 / CONFIG.AI_FPS);
          }
          
          detect();
          return true;
          
        } catch (err) {
          debugLog.add(`‚ùå MediaPipe error: ${err.message}`);
          console.error('MediaPipe error:', err);
          return false; // Don't fail, continue without hand tracking
        }
      };
      
      // ============================================
      // GESTURE PROCESSING
      // ============================================
      function onHandResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
          setGesture('idle');
          const timeSince = Date.now() - lastHandSeen.current;
          if (timeSince > 300) {
            targetRotation.current *= 0.95;
          }
          return;
        }
        
        lastHandSeen.current = Date.now();
        const landmarks = results.multiHandLandmarks[0];
        
        const wrist = landmarks[0];
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        
        const dist = (p1, p2) => {
          const dx = p1.x - p2.x;
          const dy = p1.y - p2.y;
          const dz = (p1.z || 0) - (p2.z || 0);
          return Math.sqrt(dx*dx + dy*dy + dz*dz);
        };
        
        const thumbDist = dist(thumbTip, wrist);
        const indexDist = dist(indexTip, wrist);
        const middleDist = dist(middleTip, wrist);
        const pinchDist = dist(thumbTip, indexTip);
        
        // Fist
        if (thumbDist < 0.15 && indexDist < 0.18 && middleDist < 0.18) {
          if (!isSpinning.current) {
            setGesture('magic_spin');
            isSpinning.current = true;
            spinStartTime.current = performance.now();
            targetRotation.current += Math.PI * 2;
          }
          return;
        }
        
        // Pinch
        if (pinchDist < 0.12) {
          setGesture('scaling');
          targetScale.current = Math.max(0.5, Math.min(2.0, pinchDist * 8));
          return;
        }
        
        // Rotation
        const handX = wrist.x;
        const centered = (handX - 0.5) * 2;
        
        if (Math.abs(centered) < 0.2) {
          setGesture('idle');
          targetRotation.current *= 0.9;
        } else {
          setGesture(centered < 0 ? 'rotate_left' : 'rotate_right');
          targetRotation.current += centered * CONFIG.ROTATION_SPEED;
        }
      }
      
      // ============================================
      // INITIALIZATION
      // ============================================
      useEffect(() => {
        let mounted = true;
        
        const init = async () => {
          if (!mounted) return;
          
          debugLog.add('üöÄ Starting initialization...');
          setAppState('LOADING');
          
          const cameraOK = await initCamera();
          if (!cameraOK || !mounted) return;
          
          await new Promise(r => setTimeout(r, 500));
          
          initThreeJS();
          
          await initMediaPipe();
          
          if (mounted) {
            debugLog.add('‚úÖ All systems ready!');
            setAppState('READY');
            setTimeout(() => setShowInstructions(false), 7000);
          }
        };
        
        init();
        
        return () => {
          mounted = false;
          if (videoRef.current && videoRef.current.srcObject) {
            videoRef.current.srcObject.getTracks().forEach(t => t.stop());
          }
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
        };
      }, []);
      
      // ============================================
      // UI
      // ============================================
      const gestureText = {
        idle: '‚úã Di chuy·ªÉn tay ƒë·ªÉ b·∫Øt ƒë·∫ßu',
        rotate_left: '‚Ü∂ Xoay tr√°i',
        rotate_right: '‚Ü∑ Xoay ph·∫£i',
        scaling: 'üîç Zoom',
        magic_spin: '‚ú® Ma thu·∫≠t 360¬∞!'
      };
      
      // INIT SCREEN
      if (appState === 'INIT') {
        return h('div', {
          className: 'w-screen h-screen bg-gradient-to-br from-green-700 via-red-600 to-green-800 flex items-center justify-center'
        },
          h('div', { className: 'text-center px-6' },
            h('div', { className: 'text-8xl mb-6 float-animation' }, 'üéÑ'),
            h('h1', { className: 'text-white text-4xl font-bold mb-4' }, 'AR C√¢y Th√¥ng Noel'),
            h('p', { className: 'text-white/90 text-lg mb-8' }, 'Tr·∫£i nghi·ªám AR ƒëi·ªÅu khi·ªÉn b·∫±ng tay'),
            h('button', {
              className: 'bg-white text-green-700 px-8 py-4 rounded-full text-xl font-bold shadow-2xl active:scale-95 transition-transform',
              onClick: () => setAppState('LOADING')
            }, 'üéÖ B·∫ÆT ƒê·∫¶U')
          )
        );
      }
      
      // LOADING
      if (appState === 'LOADING') {
        return h('div', {
          className: 'w-screen h-screen bg-gradient-to-b from-red-600 to-green-700 flex items-center justify-center'
        },
          h('div', { className: 'text-center' },
            h('div', { className: 'text-7xl mb-6 float-animation' }, 'üéÑ'),
            h('p', { className: 'text-white text-2xl font-bold mb-2' }, 'ƒêang kh·ªüi ƒë·ªông...'),
            h('p', { className: 'text-white/70 text-sm mb-4' }, 'Vui l√≤ng cho ph√©p camera'),
            h('div', { className: 'mt-6' },
              h('div', { 
                className: 'w-16 h-16 border-4 border-white/30 border-t-white rounded-full mx-auto',
                style: { animation: 'spin 1s linear infinite' }
              })
            ),
            CONFIG.DEBUG_MODE && h('div', { className: 'debug-panel' },
              debugLogs.map((log, i) => h('div', { key: i }, log))
            )
          )
        );
      }
      
      // ERROR
      if (appState === 'ERROR') {
        return h('div', {
          className: 'w-screen h-screen bg-red-600 flex items-center justify-center'
        },
          h('div', { className: 'text-center px-6 max-w-md' },
            h('div', { className: 'text-7xl mb-6' }, '‚ö†Ô∏è'),
            h('h2', { className: 'text-white text-2xl font-bold mb-4' }, 'C√≥ l·ªói x·∫£y ra'),
            h('p', { className: 'text-white/90 mb-6' }, errorMessage),
            h('button', {
              className: 'bg-white text-red-600 px-6 py-3 rounded-full font-bold',
              onClick: () => window.location.reload()
            }, 'üîÑ Th·ª≠ l·∫°i'),
            CONFIG.DEBUG_MODE && h('div', { className: 'debug-panel' },
              debugLogs.map((log, i) => h('div', { key: i }, log))
            )
          )
        );
      }
      
      // MAIN APP
      return h('div', { className: 'relative w-screen h-screen overflow-hidden' },
        // Video
        h('video', {
          ref: videoRef,
          className: 'absolute inset-0 w-full h-full object-cover',
          style: { transform: 'scaleX(-1)' },
          playsInline: true,
          muted: true,
          autoPlay: true
        }),
        
        // Canvas
        h('canvas', {
          ref: canvasRef,
          className: 'absolute inset-0 w-full h-full'
        }),
        
        // HUD
        h('div', { className: 'absolute inset-0 pointer-events-none' },
          h('div', { className: 'absolute top-4 left-4 right-4 flex justify-between z-10' },
            h('div', { 
              className: 'bg-black/70 backdrop-blur text-white px-4 py-2 rounded-full text-sm shadow-xl' 
            }, gestureText[gesture]),
            
            h('div', { className: 'flex gap-2' },
              h('div', { className: 'bg-black/70 text-white px-3 py-1 rounded-full text-xs' }, `${fps} FPS`),
              h('button', {
                className: 'bg-red-500 text-white px-4 py-1 rounded-full text-xs font-bold pointer-events-auto',
                onClick: () => window.location.reload()
              }, 'üîÑ')
            )
          ),
          
          showInstructions && h('div', {
            className: 'absolute bottom-24 left-0 right-0 text-center'
          },
            h('div', { className: 'bg-gradient-to-t from-black/90 to-transparent pt-12 pb-8 px-6' },
              h('h3', { className: 'text-white text-xl font-bold mb-4' }, 'üéÑ H∆∞·ªõng d·∫´n'),
              h('div', { className: 'space-y-2' },
                h('p', { className: 'text-white text-sm' }, '‚úã Di chuy·ªÉn tay tr√°i/ph·∫£i ‚Üí Xoay c√¢y'),
                h('p', { className: 'text-white text-sm' }, 'ü§è V√©o ng√≥n c√°i + tr·ªè ‚Üí Zoom'),
                h('p', { className: 'text-white text-sm' }, '‚úä N·∫Øm ƒë·∫•m ‚Üí Xoay 360¬∞')
              ),
              h('button', {
                className: 'mt-4 text-white/60 text-xs underline pointer-events-auto',
                onClick: () => setShowInstructions(false)
              }, '·∫®n h∆∞·ªõng d·∫´n')
            )
          ),
          
          h('div', { className: 'absolute bottom-6 left-0 right-0 text-center' },
            h('a', {
              href: '#',
              className: 'text-white/80 text-sm italic pointer-events-auto',
              style: { textShadow: '0 2px 12px rgba(0,0,0,0.9)' }
            }, '‚ú® Created by V≈© Kim V·ªØng')
          ),
          
          CONFIG.DEBUG_MODE && h('div', { className: 'debug-panel' },
            h('div', { className: 'font-bold mb-2' }, 'üîç Debug Console'),
            debugLogs.map((log, i) => h('div', { key: i, className: 'text-[9px]' }, log))
          )
        )
      );
    }
    
    // Render
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(h(App));
  </script>
</body>
</html>
