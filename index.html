<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  
  <title>ðŸŽ„ AR CÃ¢y ThÃ´ng Noel - Tráº£i nghiá»‡m AR trÃªn tay</title>
  
  <!-- SEO & Social Meta -->
  <meta name="description" content="Äiá»u khiá»ƒn cÃ¢y thÃ´ng Noel 3D báº±ng cá»­ chá»‰ tay - Tráº£i nghiá»‡m AR Ä‘á»™c Ä‘Ã¡o">
  <meta name="theme-color" content="#165B33">
  <meta property="og:title" content="AR CÃ¢y ThÃ´ng Noel">
  <meta property="og:description" content="Tráº£i nghiá»‡m AR tÆ°Æ¡ng tÃ¡c vá»›i bÃ n tay">
  <meta property="og:type" content="website">
  
  <!-- CDN Libraries -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@mediapipe/hands@0.4.1646424915/hands.js"></script>
  <script src="https://unpkg.com/@mediapipe/camera_utils@0.3.1620248168/camera_utils.js"></script>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: 'Georgia', serif;
      touch-action: none;
      -webkit-tap-highlight-color: transparent;
    }
    
    html, body {
      position: fixed;
      width: 100%;
      height: 100%;
    }
    
    #root {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      height: 100dvh;
    }
    
    /* Prevent iOS Safari bounce */
    body {
      overscroll-behavior: none;
    }
    
    /* Loading animation */
    @keyframes float {
      0%, 100% { transform: translateY(0px); }
      50% { transform: translateY(-20px); }
    }
    
    .float-animation {
      animation: float 2s ease-in-out infinite;
    }
    
    /* Fade in/out */
    .fade-enter {
      opacity: 0;
      transition: opacity 0.5s;
    }
    
    .fade-enter-active {
      opacity: 1;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script>
    'use strict';
    
    // ============================================
    // DEVICE DETECTION & CONFIGURATION
    // ============================================
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    const CONFIG = isMobile ? {
      CAMERA_WIDTH: 640,
      CAMERA_HEIGHT: 480,
      AI_FPS: 10,
      SNOW_PARTICLES: 80,
      ORNAMENT_COUNT: 12,
      ENABLE_ANTIALIASING: false,
      PIXEL_RATIO: Math.min(window.devicePixelRatio, 2),
      DAMPING: 0.12,
      ROTATION_SPEED: 0.04,
      SCALE_SENSITIVITY: 6
    } : {
      CAMERA_WIDTH: 1280,
      CAMERA_HEIGHT: 720,
      AI_FPS: 15,
      SNOW_PARTICLES: 200,
      ORNAMENT_COUNT: 20,
      ENABLE_ANTIALIASING: true,
      PIXEL_RATIO: window.devicePixelRatio,
      DAMPING: 0.08,
      ROTATION_SPEED: 0.05,
      SCALE_SENSITIVITY: 8
    };
    
    // ============================================
    // REACT SETUP
    // ============================================
    const { useState, useEffect, useRef, createElement: h } = React;
    
    // ============================================
    // MAIN APP COMPONENT
    // ============================================
    function App() {
      // State
      const [appState, setAppState] = useState('INIT'); // INIT | LOADING | READY | ERROR
      const [gesture, setGesture] = useState('idle');
      const [fps, setFPS] = useState(60);
      const [showInstructions, setShowInstructions] = useState(true);
      const [errorMessage, setErrorMessage] = useState('');
      
      // Refs
      const videoRef = useRef(null);
      const canvasRef = useRef(null);
      const sceneRef = useRef(null);
      const handsRef = useRef(null);
      const animationFrameRef = useRef(null);
      
      // Gesture targets
      const targetRotation = useRef(0);
      const targetScale = useRef(1);
      const isSpinning = useRef(false);
      const spinStartTime = useRef(0);
      
      // Performance tracking
      const lastFrameTime = useRef(performance.now());
      const frameCount = useRef(0);
      const lastHandSeen = useRef(Date.now());
      
      // ============================================
      // CAMERA INITIALIZATION
      // ============================================
      const initCamera = async () => {
        try {
          const constraints = {
            video: {
              facingMode: 'user',
              width: { ideal: CONFIG.CAMERA_WIDTH },
              height: { ideal: CONFIG.CAMERA_HEIGHT },
              frameRate: { ideal: 30 }
            },
            audio: false
          };
          
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          
          if (videoRef.current) {
            videoRef.current.srcObject = stream;
            videoRef.current.setAttribute('playsinline', 'true');
            videoRef.current.setAttribute('webkit-playsinline', 'true');
            
            await new Promise((resolve) => {
              videoRef.current.onloadedmetadata = () => {
                videoRef.current.play().then(resolve);
              };
            });
          }
          
          return true;
        } catch (err) {
          console.error('Camera error:', err);
          setErrorMessage(
            err.name === 'NotAllowedError' 
              ? 'Báº¡n cáº§n cho phÃ©p truy cáº­p camera Ä‘á»ƒ sá»­ dá»¥ng AR'
              : 'KhÃ´ng thá»ƒ káº¿t ná»‘i camera. Vui lÃ²ng kiá»ƒm tra thiáº¿t bá»‹.'
          );
          setAppState('ERROR');
          return false;
        }
      };
      
      // ============================================
      // THREE.JS SCENE SETUP
      // ============================================
      const initThreeJS = () => {
        if (!canvasRef.current) return;
        
        const width = window.innerWidth;
        const height = window.innerHeight;
        
        // Scene
        const scene = new THREE.Scene();
        
        // Camera
        const camera = new THREE.PerspectiveCamera(50, width / height, 0.1, 1000);
        const cameraDistance = isMobile ? 7 : 5;
        camera.position.set(0, 2, cameraDistance);
        camera.lookAt(0, 1.5, 0);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({
          canvas: canvasRef.current,
          alpha: true,
          antialias: CONFIG.ENABLE_ANTIALIASING,
          powerPreference: 'high-performance'
        });
        renderer.setSize(width, height);
        renderer.setPixelRatio(CONFIG.PIXEL_RATIO);
        renderer.setClearColor(0x000000, 0);
        
        // Lights
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        scene.add(directionalLight);
        
        // ============================================
        // CREATE CHRISTMAS TREE
        // ============================================
        const treeGroup = new THREE.Group();
        
        // Trunk
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.25, 1, 8);
        const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 0.5;
        treeGroup.add(trunk);
        
        // Foliage - 3 tiers
        const foliageMaterial = new THREE.MeshPhongMaterial({ 
          color: 0x0F5E32,
          flatShading: true
        });
        
        const tier1 = new THREE.Mesh(
          new THREE.ConeGeometry(1.2, 1.5, 8), 
          foliageMaterial
        );
        tier1.position.y = 1.5;
        treeGroup.add(tier1);
        
        const tier2 = new THREE.Mesh(
          new THREE.ConeGeometry(0.9, 1.2, 8), 
          foliageMaterial
        );
        tier2.position.y = 2.3;
        treeGroup.add(tier2);
        
        const tier3 = new THREE.Mesh(
          new THREE.ConeGeometry(0.6, 1, 8), 
          foliageMaterial
        );
        tier3.position.y = 3;
        treeGroup.add(tier3);
        
        // Star on top
        const starGeometry = new THREE.IcosahedronGeometry(0.2, 0);
        const starMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xFFD700,
          emissive: 0xFFD700,
          emissiveIntensity: 1
        });
        const star = new THREE.Mesh(starGeometry, starMaterial);
        star.position.y = 3.8;
        treeGroup.add(star);
        
        // Ornaments
        const ornamentColors = [0xFF0000, 0x0000FF, 0xFFD700, 0xFF69B4, 0x00FF00, 0xFF1493];
        const ornaments = [];
        
        for (let i = 0; i < CONFIG.ORNAMENT_COUNT; i++) {
          const ornament = new THREE.Mesh(
            new THREE.SphereGeometry(0.08, 8, 8),
            new THREE.MeshStandardMaterial({
              color: ornamentColors[i % ornamentColors.length],
              metalness: 0.7,
              roughness: 0.3,
              emissive: ornamentColors[i % ornamentColors.length],
              emissiveIntensity: 0.2
            })
          );
          
          // Distribute on tree
          const tier = Math.floor(i / (CONFIG.ORNAMENT_COUNT / 3));
          const angle = (i * 137.5) * (Math.PI / 180); // Golden angle
          const radius = 0.3 + (Math.random() * 0.4) - (tier * 0.15);
          const height = 1.2 + tier * 0.8 + (Math.random() * 0.3);
          
          ornament.position.set(
            Math.cos(angle) * radius,
            height,
            Math.sin(angle) * radius
          );
          
          treeGroup.add(ornament);
          ornaments.push(ornament);
        }
        
        // Internal glow light
        const pointLight = new THREE.PointLight(0xFFAA00, 1.5, 6);
        pointLight.position.set(0, 2, 0);
        treeGroup.add(pointLight);
        
        scene.add(treeGroup);
        
        // ============================================
        // SNOW PARTICLE SYSTEM
        // ============================================
        const snowGeometry = new THREE.BufferGeometry();
        const snowPositions = new Float32Array(CONFIG.SNOW_PARTICLES * 3);
        const snowVelocities = [];
        
        for (let i = 0; i < CONFIG.SNOW_PARTICLES; i++) {
          snowPositions[i * 3] = (Math.random() - 0.5) * 10;
          snowPositions[i * 3 + 1] = Math.random() * 10;
          snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 10;
          
          snowVelocities.push(0.01 + Math.random() * 0.02);
        }
        
        snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
        
        const snowMaterial = new THREE.PointsMaterial({
          color: 0xFFFFFF,
          size: isMobile ? 0.05 : 0.08,
          transparent: true,
          opacity: 0.9,
          sizeAttenuation: true
        });
        
        const snowSystem = new THREE.Points(snowGeometry, snowMaterial);
        scene.add(snowSystem);
        
        // ============================================
        // ANIMATION LOOP
        // ============================================
        function animate() {
          animationFrameRef.current = requestAnimationFrame(animate);
          
          // FPS Counter
          frameCount.current++;
          const now = performance.now();
          if (now - lastFrameTime.current > 1000) {
            setFPS(frameCount.current);
            frameCount.current = 0;
            lastFrameTime.current = now;
          }
          
          // Handle magic spin animation
          if (isSpinning.current) {
            const elapsed = (now - spinStartTime.current) / 1000;
            if (elapsed < 2) {
              targetRotation.current += 0.15; // Fast spin
            } else {
              isSpinning.current = false;
            }
          }
          
          // Smooth interpolation
          treeGroup.rotation.y += (targetRotation.current - treeGroup.rotation.y) * CONFIG.DAMPING;
          
          const currentScale = treeGroup.scale.x;
          const newScale = currentScale + (targetScale.current - currentScale) * CONFIG.DAMPING;
          treeGroup.scale.set(newScale, newScale, newScale);
          
          // Rotate star continuously
          star.rotation.y += 0.02;
          
          // Ornament sparkle effect
          ornaments.forEach((ornament, i) => {
            const sparkle = Math.sin(now * 0.003 + i) * 0.5 + 0.5;
            ornament.material.emissiveIntensity = 0.2 + sparkle * 0.3;
          });
          
          // Snow animation
          const positions = snowGeometry.attributes.position.array;
          for (let i = 0; i < CONFIG.SNOW_PARTICLES; i++) {
            positions[i * 3 + 1] -= snowVelocities[i];
            
            // Reset when hits ground
            if (positions[i * 3 + 1] < -1) {
              positions[i * 3 + 1] = 10;
              positions[i * 3] = (Math.random() - 0.5) * 10;
              positions[i * 3 + 2] = (Math.random() - 0.5) * 10;
            }
          }
          snowGeometry.attributes.position.needsUpdate = true;
          
          // Render
          renderer.render(scene, camera);
        }
        
        animate();
        
        // Store refs
        sceneRef.current = { 
          scene, 
          camera, 
          renderer, 
          treeGroup,
          star,
          ornaments,
          snowSystem 
        };
        
        // Handle resize
        const handleResize = () => {
          const width = window.innerWidth;
          const height = window.innerHeight;
          camera.aspect = width / height;
          camera.updateProjectionMatrix();
          renderer.setSize(width, height);
        };
        
        window.addEventListener('resize', handleResize);
        window.addEventListener('orientationchange', () => {
          setTimeout(handleResize, 100);
        });
        
        return () => {
          window.removeEventListener('resize', handleResize);
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
        };
      };
      
      // ============================================
      // MEDIAPIPE HAND TRACKING
      // ============================================
      const initMediaPipe = async () => {
        try {
          const hands = new Hands({
            locateFile: (file) => {
              return `https://unpkg.com/@mediapipe/hands@0.4.1646424915/${file}`;
            }
          });
          
          hands.setOptions({
            maxNumHands: 1,
            modelComplexity: isMobile ? 0 : 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
          });
          
          hands.onResults(onHandResults);
          
          await hands.initialize();
          
          handsRef.current = hands;
          
          // AI Detection Loop
          let isProcessing = false;
          
          async function detectHands() {
            if (videoRef.current && handsRef.current && !isProcessing) {
              isProcessing = true;
              try {
                await handsRef.current.send({ image: videoRef.current });
              } catch (err) {
                console.warn('Detection error:', err);
              } finally {
                isProcessing = false;
              }
            }
            setTimeout(detectHands, 1000 / CONFIG.AI_FPS);
          }
          
          detectHands();
          
          return true;
        } catch (err) {
          console.error('MediaPipe init error:', err);
          setErrorMessage('KhÃ´ng thá»ƒ khá»Ÿi Ä‘á»™ng AI hand tracking');
          setAppState('ERROR');
          return false;
        }
      };
      
      // ============================================
      // GESTURE PROCESSING
      // ============================================
      function onHandResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
          setGesture('idle');
          
          // Decay rotation when hand lost
          const timeSinceLastHand = Date.now() - lastHandSeen.current;
          if (timeSinceLastHand > 300) {
            targetRotation.current *= 0.95;
          }
          
          return;
        }
        
        lastHandSeen.current = Date.now();
        const landmarks = results.multiHandLandmarks[0];
        
        // Key landmarks
        const wrist = landmarks[0];
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];
        
        // Calculate distances
        const thumbToWrist = distance3D(thumbTip, wrist);
        const indexToWrist = distance3D(indexTip, wrist);
        const middleToWrist = distance3D(middleTip, wrist);
        const pinchDistance = distance3D(thumbTip, indexTip);
        
        // ============================================
        // GESTURE 1: FIST DETECTION (Magic Spin)
        // ============================================
        if (thumbToWrist < 0.15 && indexToWrist < 0.18 && middleToWrist < 0.18) {
          if (!isSpinning.current) {
            setGesture('magic_spin');
            isSpinning.current = true;
            spinStartTime.current = performance.now();
            targetRotation.current += Math.PI * 2;
          }
          return;
        }
        
        // ============================================
        // GESTURE 2: PINCH (Scaling)
        // ============================================
        if (pinchDistance < 0.12) {
          setGesture('scaling');
          const normalizedDistance = Math.max(0.02, Math.min(0.3, pinchDistance));
          targetScale.current = Math.max(0.5, Math.min(2.0, normalizedDistance * CONFIG.SCALE_SENSITIVITY));
          return;
        }
        
        // ============================================
        // GESTURE 3: ROTATION (Default)
        // ============================================
        const handX = wrist.x;
        const centered = (handX - 0.5) * 2; // [-1, 1]
        
        const DEADZONE = 0.2;
        
        if (Math.abs(centered) < DEADZONE) {
          setGesture('idle');
          targetRotation.current *= 0.92;
        } else {
          if (centered < 0) {
            setGesture('rotate_left');
          } else {
            setGesture('rotate_right');
          }
          
          targetRotation.current += centered * CONFIG.ROTATION_SPEED;
        }
      }
      
      function distance3D(p1, p2) {
        const dx = p1.x - p2.x;
        const dy = p1.y - p2.y;
        const dz = (p1.z || 0) - (p2.z || 0);
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
      }
      
      // ============================================
      // INITIALIZATION SEQUENCE
      // ============================================
      useEffect(() => {
        let mounted = true;
        
        const init = async () => {
          if (!mounted) return;
          
          setAppState('LOADING');
          
          // Step 1: Camera
          const cameraOK = await initCamera();
          if (!cameraOK || !mounted) return;
          
          // Small delay for video to stabilize
          await new Promise(resolve => setTimeout(resolve, 500));
          
          // Step 2: Three.js
          initThreeJS();
          
          // Step 3: MediaPipe
          const mpOK = await initMediaPipe();
          if (!mpOK || !mounted) return;
          
          // Ready!
          setAppState('READY');
          
          // Auto-hide instructions
          setTimeout(() => {
            if (mounted) setShowInstructions(false);
          }, 6000);
        };
        
        init();
        
        return () => {
          mounted = false;
          
          // Cleanup
          if (videoRef.current && videoRef.current.srcObject) {
            const tracks = videoRef.current.srcObject.getTracks();
            tracks.forEach(track => track.stop());
          }
          
          if (animationFrameRef.current) {
            cancelAnimationFrame(animationFrameRef.current);
          }
        };
      }, []);
      
      // ============================================
      // GESTURE TEXT MAPPING
      // ============================================
      const gestureText = {
        idle: 'âœ‹ Di chuyá»ƒn tay Ä‘á»ƒ báº¯t Ä‘áº§u',
        rotate_left: 'â†¶ Äang xoay trÃ¡i',
        rotate_right: 'â†· Äang xoay pháº£i',
        scaling: 'ðŸ” Äang zoom',
        magic_spin: 'âœ¨ Ma thuáº­t 360Â°!'
      };
      
      // ============================================
      // UI RENDERING
      // ============================================
      
      // INIT SCREEN
      if (appState === 'INIT') {
        return h('div', {
          className: 'w-screen h-screen bg-gradient-to-br from-green-700 via-red-600 to-green-800 flex items-center justify-center'
        },
          h('div', { className: 'text-center px-6' },
            h('div', { className: 'text-8xl mb-6 float-animation' }, 'ðŸŽ„'),
            h('h1', { 
              className: 'text-white text-4xl font-bold mb-4',
              style: { textShadow: '0 4px 12px rgba(0,0,0,0.5)' }
            }, 'AR CÃ¢y ThÃ´ng Noel'),
            h('p', { className: 'text-white/90 text-lg mb-8' }, 
              'Tráº£i nghiá»‡m AR Ä‘iá»u khiá»ƒn báº±ng tay'
            ),
            h('button', {
              className: 'bg-white text-green-700 px-8 py-4 rounded-full text-xl font-bold shadow-2xl active:scale-95 transition-transform',
              onClick: () => setAppState('LOADING')
            }, 'ðŸŽ… Báº®T Äáº¦U')
          )
        );
      }
      
      // LOADING SCREEN
      if (appState === 'LOADING') {
        return h('div', {
          className: 'w-screen h-screen bg-gradient-to-b from-red-600 to-green-700 flex items-center justify-center z-50'
        },
          h('div', { className: 'text-center' },
            h('div', { className: 'text-7xl mb-6 float-animation' }, 'ðŸŽ„'),
            h('p', { className: 'text-white text-2xl font-bold mb-2' }, 'Äang táº£i phÃ©p mÃ u...'),
            h('p', { className: 'text-white/70 text-sm' }, 'Vui lÃ²ng cho phÃ©p truy cáº­p camera'),
            h('div', { className: 'mt-6' },
              h('div', { 
                className: 'w-16 h-16 border-4 border-white/30 border-t-white rounded-full mx-auto',
                style: { animation: 'spin 1s linear infinite' }
              })
            )
          )
        );
      }
      
      // ERROR SCREEN
      if (appState === 'ERROR') {
        return h('div', {
          className: 'w-screen h-screen bg-red-600 flex items-center justify-center z-50'
        },
          h('div', { className: 'text-center px-6 max-w-md' },
            h('div', { className: 'text-7xl mb-6' }, 'âš ï¸'),
            h('h2', { className: 'text-white text-2xl font-bold mb-4' }, 'Oops!'),
            h('p', { className: 'text-white/90 text-lg mb-6' }, errorMessage),
            h('div', { className: 'space-y-3' },
              h('p', { className: 'text-white/70 text-sm' }, 
                'LÆ°u Ã½: Cáº§n dÃ¹ng HTTPS vÃ  trÃ¬nh duyá»‡t Chrome/Safari'
              ),
              h('button', {
                className: 'bg-white text-red-600 px-6 py-3 rounded-full font-bold shadow-lg active:scale-95 transition-transform',
                onClick: () => window.location.reload()
              }, 'ðŸ”„ Thá»­ láº¡i')
            )
          )
        );
      }
      
      // MAIN AR INTERFACE
      return h('div', { className: 'relative w-screen h-screen overflow-hidden bg-black' },
        // Video Background
        h('video', {
          ref: videoRef,
          className: 'absolute inset-0 w-full h-full object-cover',
          style: { transform: 'scaleX(-1)' },
          playsInline: true,
          muted: true,
          autoPlay: true
        }),
        
        // Three.js Canvas
        h('canvas', {
          ref: canvasRef,
          className: 'absolute inset-0 w-full h-full'
        }),
        
        // HUD Overlay
        h('div', { className: 'absolute inset-0 pointer-events-none' },
          // Top Bar
          h('div', { className: 'absolute top-4 left-4 right-4 flex justify-between items-start z-10' },
            h('div', { 
              className: 'bg-black/70 backdrop-blur-sm text-white px-4 py-2 rounded-full text-sm font-medium shadow-xl border border-white/20' 
            }, gestureText[gesture] || 'Idle'),
            
            h('div', { 
              className: 'flex gap-2'
            },
              h('div', { 
                className: 'bg-black/70 backdrop-blur-sm text-white px-3 py-1 rounded-full text-xs border border-white/20' 
              }, `${fps} FPS`),
              
              h('button', {
                className: 'bg-red-500/90 backdrop-blur-sm text-white px-4 py-1 rounded-full text-xs font-bold pointer-events-auto active:scale-95 transition-transform shadow-xl',
                onClick: () => window.location.reload()
              }, 'ðŸ”„')
            )
          ),
          
          // Instructions (conditional)
          showInstructions && h('div', {
            className: 'absolute bottom-24 left-0 right-0 text-center transition-opacity duration-1000'
          },
            h('div', { 
              className: 'bg-gradient-to-t from-black/90 via-black/70 to-transparent pt-12 pb-8 px-6' 
            },
              h('h3', { 
                className: 'text-white text-xl font-bold mb-4',
                style: { textShadow: '0 2px 8px rgba(0,0,0,0.8)' }
              }, 'ðŸŽ„ HÆ°á»›ng dáº«n sá»­ dá»¥ng'),
              
              h('div', { className: 'space-y-2 max-w-sm mx-auto' },
                h('p', { className: 'text-white/95 text-sm flex items-center justify-center gap-2' },
                  h('span', {}, 'âœ‹'),
                  h('span', {}, 'Di chuyá»ƒn tay trÃ¡i/pháº£i Ä‘á»ƒ xoay cÃ¢y')
                ),
                h('p', { className: 'text-white/95 text-sm flex items-center justify-center gap-2' },
                  h('span', {}, 'ðŸ¤'),
                  h('span', {}, 'VÃ©o ngÃ³n cÃ¡i + trá» Ä‘á»ƒ phÃ³ng to/thu nhá»')
                ),
                h('p', { className: 'text-white/95 text-sm flex items-center justify-center gap-2' },
                  h('span', {}, 'âœŠ'),
                  h('span', {}, 'Náº¯m Ä‘áº¥m Ä‘á»ƒ xoay vÃ²ng 360Â°')
                )
              ),
              
              h('button', {
                className: 'mt-6 text-white/60 text-xs underline pointer-events-auto',
                onClick: () => setShowInstructions(false)
              }, 'ÄÃ£ hiá»ƒu, áº©n hÆ°á»›ng dáº«n')
            )
          ),
          
          // Branding
          h('div', { className: 'absolute bottom-6 left-0 right-0 text-center z-10' },
            h('a', {
              href: 'https://github.com/vukimvung',
              target: '_blank',
              rel: 'noopener noreferrer',
              className: 'text-white/80 text-sm font-serif italic pointer-events-auto hover:text-white transition-colors',
              style: { textShadow: '0 2px 12px rgba(0,0,0,0.9)' }
            }, 'âœ¨ Created by VÅ© Kim Vá»¯ng')
          )
        )
      );
    }
    
    // ============================================
    // RENDER TO DOM
    // ============================================
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(h(App));
    
    // ============================================
    // PERFORMANCE MONITORING
    // ============================================
    if (window.performance && console.table) {
      window.addEventListener('load', () => {
        setTimeout(() => {
          const perfData = performance.getEntriesByType('navigation')[0];
          console.log('ðŸ“Š Performance Metrics:');
          console.table({
            'Page Load': `${Math.round(perfData.loadEventEnd - perfData.fetchStart)}ms`,
            'DOM Ready': `${Math.round(perfData.domContentLoadedEventEnd - perfData.fetchStart)}ms`,
            'Transfer Size': `${Math.round(perfData.transferSize / 1024)}KB`
          });
        }, 2000);
      });
    }
    
    // ============================================
    // Add spin animation to style
    // ============================================
    const style = document.createElement('style');
    style.textContent = `
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
    `;
    document.head.appendChild(style);
  </script>
</body>
</html>